// Hardcoded Key for Demo (Must match Backend)
// In a real app, this key should be derived from a user password or key exchange (ECDH).
// '31323334...' is hex for '1234...'
const KEY_HEX = "3132333435363738393031323334353637383930313233343536373839303132"; 

async function fetchAndDecrypt() {
    const statusDiv = document.getElementById('status');
    const contentDiv = document.getElementById('content');
    
    statusDiv.innerText = "데이터 요청 중...";
    contentDiv.innerText = "";

    try {
        // 1. Fetch Encrypted Data
        // Note: You need to run the backend and enable CORS or use a proxy. 
        // For this file-based demo, we'll simulate the response if the fetch fails.
        let responseData;
        try {
            const response = await fetch('http://localhost:8080/api/novels/1');
            if (!response.ok) throw new Error("Network response was not ok");
            responseData = await response.json();
        } catch (e) {
            console.warn("Backend fetch failed, using mock data for demonstration.");
             // Simulate backend response for '12345678901234567890123456789012' key and plaintext "이것은 비밀 소설 내용입니다. GCM 모드로 보호됩니다."
            // This is just to show the decryption logic works without running backend.
            // WARNING: The mocked data below needs to be generated by the actual backend to be valid. 
            // Since we can't easily generate valid GCM ciphertext here without the lib, we will rely on users running the backend.
            statusDiv.innerText = "백엔드 연결 실패. 백엔드를 실행해주세요.";
            return;
        }

        const encryptedBase64 = responseData.content;
        statusDiv.innerText = "복호화 중...";

        // 2. Decode Base64
        const encryptedBytes = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));

        // 3. Extract IV (12 bytes) and Ciphertext
        const iv = encryptedBytes.slice(0, 12);
        const ciphertext = encryptedBytes.slice(12);

        // 4. Import Key
        const keyBytes = new TextEncoder().encode("12345678901234567890123456789012");
        const key = await window.crypto.subtle.importKey(
            "raw",
            keyBytes,
            { name: "AES-GCM" },
            false,
            ["decrypt"]
        );

        // 5. Decrypt
        const decryptedBuffer = await window.crypto.subtle.decrypt(
            {
                name: "AES-GCM",
                iv: iv,
                tagLength: 128 // GCM Tag Length
            },
            key,
            ciphertext
        );

        // 6. Display Result
        const dec = new TextDecoder();
        contentDiv.innerText = dec.decode(decryptedBuffer);
        statusDiv.innerText = "완료!";

    } catch (err) {
        console.error(err);
        statusDiv.innerHTML = `<span class="error">오류 발생: ${err.message}</span>`;
        if (err.name === "OperationError") {
             statusDiv.innerHTML += "<br><small>(복호화 실패: 키가 틀리거나 데이터가 변조되었을 수 있습니다.)</small>";
        }
    }
}
